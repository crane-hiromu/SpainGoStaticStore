name: Generate Release JSON File

on:
  workflow_dispatch:
    inputs:
      date:
        description: 'Date (e.g., 2024/02/07)'
        required: false
      version:
        description: 'Version (e.g., 1.32.0)'
        required: false

jobs:
  generate-json:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Generate File Name from Date
        id: generate_file_name
        run: |
          DATE=${{ github.event.inputs.date || '' }}
          if [ -z "$DATE" ]; then DATE=$(date +'%Y/%m/%d'); fi
          FORMATTED_DATE=$(echo "$DATE" | sed 's|/||g')
          BASE_FILE_NAME="Info/${FORMATTED_DATE}"
          FILE_NAME="${BASE_FILE_NAME}.json"
          
          # Auto-detect version if not provided
          INPUT_VERSION="${{ github.event.inputs.version || '' }}"
          if [ -z "$INPUT_VERSION" ]; then
            # Find the latest release (type 101) and extract version
            mapfile -d '' sorted_json_files < <(find Info -maxdepth 1 -name '*.json' -print0 | sort -rz)
            for json_file in "${sorted_json_files[@]}"; do
              file_type=$(jq -r '.type' "$json_file" 2>/dev/null || echo "")
              if [ "$file_type" = "101" ]; then
                # Extract version from outline field
                outline=$(jq -r '.outline' "$json_file" 2>/dev/null || echo "")
                if [[ $outline =~ 新しいバージョン\ ([0-9]+\.[0-9]+\.[0-9]+) ]]; then
                  prev_version="${BASH_REMATCH[1]}"
                  # Split version into major.minor.patch
                  IFS='.' read -r major minor patch <<< "$prev_version"
                  # Increment minor version
                  new_minor=$((minor + 1))
                  VERSION="${major}.${new_minor}.0"
                  echo "Auto-detected previous version: $prev_version"
                  echo "New version: $VERSION"
                  break
                fi
              fi
            done
            # Fallback if no version found
            if [ -z "$VERSION" ]; then
              VERSION="1.1.0"
              echo "No previous release found, using default version: $VERSION"
            fi
          else
            VERSION="$INPUT_VERSION"
            echo "Using manually provided version: $VERSION"
          fi
          
          # Check if file exists and add version suffix if needed
          FILE_VERSION=2
          while [ -f "$FILE_NAME" ]; do
            FILE_NAME="${BASE_FILE_NAME}_v${FILE_VERSION}.json"
            FILE_VERSION=$((FILE_VERSION + 1))
          done
          
          echo "FILE_NAME=${FILE_NAME}" >> $GITHUB_ENV
          echo "JSON_DATE=${DATE}" >> $GITHUB_ENV
          echo "JSON_VERSION=${VERSION}" >> $GITHUB_ENV

      - name: Generate JSON File
        run: |
          JSON_CONTENT=$(cat <<EOF
          {
              "date": "${JSON_DATE}",
              "type": 101,
              "title": "アプリのアップデート",
              "outline": "新しいバージョン ${JSON_VERSION} がリリースされました",
              "description": "**【アップデート内容】**\n- xxx\n\n**【バージョン】**\nバージョン：${JSON_VERSION}\nApp Store：[スペインゴ](https://apps.apple.com/jp/app/%E3%82%B9%E3%83%9A%E3%82%A4%E3%83%B3%E3%82%B4/id6469019716)",
              "published": false
          }
          EOF
          )
          echo "$JSON_CONTENT" > $FILE_NAME

      - name: Commit and Push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add $FILE_NAME
          git commit -m "Add $FILE_NAME"
          git push
